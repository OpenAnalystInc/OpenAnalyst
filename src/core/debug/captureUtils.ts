import * as fs from "fs"
import * as path from "path"
import { Anthropic } from "@anthropic-ai/sdk"

// Compile-time flag provided by bundler (see esbuild define)
declare const __DEV__: boolean

interface SystemPromptCaptureOptions {
	mode?: string
	activeBlocks?: string[]
	customInstructions?: boolean
	taskId?: string
}

interface ApiCallCaptureOptions {
	provider: string
	model: string
	taskId: string
	mode?: string
	systemPrompt: string
	messages: Anthropic.Messages.MessageParam[]
	metadata?: any
	response?: string
	tokenUsage?: {
		input?: number
		output?: number
	}
	// Enhanced capture data
	userRequest?: string
	rawRequest?: {
		url?: string
		method?: string
		headers?: Record<string, string>
		body?: string
	}
	rawResponse?: {
		status?: number
		statusText?: string
		headers?: Record<string, string>
		body?: string
	}
	timing?: {
		requestStart?: string
		responseStart?: string
		responseEnd?: string
		duration?: number
	}
}

/**
 * Creates a timestamp string for filename use
 * Format: 2025-01-16_14-30-15
 */
function createTimestamp(): string {
	const now = new Date()
	return now.toISOString()
		.replace(/T/, '_')
		.replace(/:/g, '-')
		.replace(/\..+/, '')
		.slice(0, 19) // YYYY-MM-DD_HH-MM-SS
}

/**
 * Ensures the debug directory exists
 */
function ensureDebugDirectory(): string {
	// Go up from src/core/debug to project root (OpenAnalyst), then to system_prompt
	// __dirname is the compiled dist directory, so we need to find the actual project root
	let projectRoot = path.resolve(__dirname, "..", "..", "..")

	// If we're in the dist directory, go up one more level to reach the true project root
	if (projectRoot.endsWith('dist') || projectRoot.includes('dist')) {
		projectRoot = path.resolve(__dirname, "..", "..", "..", "..")
	}

	// Ensure we're in the OpenAnalyst directory (not going too far up)
	if (!projectRoot.includes('OpenAnalyst')) {
		// Fallback: assume we need to go to the parent of dist
		projectRoot = path.resolve(__dirname, "..")
		while (!projectRoot.endsWith('OpenAnalyst') && projectRoot !== path.dirname(projectRoot)) {
			projectRoot = path.dirname(projectRoot)
		}
	}

	const debugDir = path.join(projectRoot, "system_prompt")

	// Debug logging to help troubleshoot path issues
	if (__DEV__) {
		console.log(`[DEBUG] Path resolution:`)
		console.log(`[DEBUG] __dirname: ${__dirname}`)
		console.log(`[DEBUG] Resolved project root: ${projectRoot}`)
		console.log(`[DEBUG] Debug directory: ${debugDir}`)
	}

	const systemPromptsDir = path.join(debugDir, "system_prompts")
	const apiCallsDir = path.join(debugDir, "api_calls")

	if (!fs.existsSync(systemPromptsDir)) {
		fs.mkdirSync(systemPromptsDir, { recursive: true })
	}

	if (!fs.existsSync(apiCallsDir)) {
		fs.mkdirSync(apiCallsDir, { recursive: true })
	}

	return debugDir
}

/**
 * Captures system prompt to markdown file
 * Only works when __DEV__ is true
 */
export function captureSystemPrompt(systemPrompt: string, options: SystemPromptCaptureOptions = {}): void {
	// Only capture in development mode
	if (!__DEV__) {
		return
	}

	try {
		const debugDir = ensureDebugDirectory()
		const timestamp = createTimestamp()
		const filename = `system_prompt_${timestamp}.md`
		const filePath = path.join(debugDir, "system_prompts", filename)

		const content = `# System Prompt Capture
**Timestamp**: ${new Date().toLocaleString()}
**Mode**: ${options.mode || 'unknown'}
**Active Blocks**: ${options.activeBlocks ? JSON.stringify(options.activeBlocks) : 'none'}
**Custom Instructions**: ${options.customInstructions ? 'Yes' : 'No'}
**Task ID**: ${options.taskId || 'unknown'}

## Full System Prompt
\`\`\`
${systemPrompt}
\`\`\`

---
*Generated by OpenAnalyst Debug Capture*
`

		fs.writeFileSync(filePath, content, 'utf-8')
		console.log(`[DEBUG] System prompt captured: ${filename}`)
	} catch (error) {
		console.error('[DEBUG] Failed to capture system prompt:', error)
	}
}

/**
 * Captures API call and response to markdown file
 * Only works when __DEV__ is true
 */
export function captureApiCall(options: ApiCallCaptureOptions): void {
	// Only capture in development mode
	if (!__DEV__) {
		return
	}

	try {
		const debugDir = ensureDebugDirectory()
		const timestamp = createTimestamp()
		const filename = `api_call_${timestamp}.md`
		const filePath = path.join(debugDir, "api_calls", filename)

		const content = `# API Call Capture
**Timestamp**: ${new Date().toLocaleString()}
**Provider**: ${options.provider}
**Model**: ${options.model}
**Task ID**: ${options.taskId}
**Mode**: ${options.mode || 'unknown'}

## User Request
\`\`\`
${options.userRequest || 'No user request captured'}
\`\`\`

## Request Details
### System Prompt
\`\`\`
${options.systemPrompt}
\`\`\`

### Messages (Conversation History)
\`\`\`json
${JSON.stringify(options.messages, null, 2)}
\`\`\`

### Request Metadata
\`\`\`json
${JSON.stringify(options.metadata, null, 2)}
\`\`\`

## Raw HTTP Request
${options.rawRequest ? `
### URL & Method
- **URL**: ${options.rawRequest.url || 'Not captured'}
- **Method**: ${options.rawRequest.method || 'Not captured'}

### Request Headers
\`\`\`json
${JSON.stringify(options.rawRequest.headers || {}, null, 2)}
\`\`\`

### Request Body
\`\`\`json
${options.rawRequest.body || 'Not captured'}
\`\`\`
` : '\`\`\`\nRaw HTTP request data not captured\n\`\`\`'}

## Raw HTTP Response
${options.rawResponse ? `
### Response Status
- **Status**: ${options.rawResponse.status || 'Not captured'}
- **Status Text**: ${options.rawResponse.statusText || 'Not captured'}

### Response Headers
\`\`\`json
${JSON.stringify(options.rawResponse.headers || {}, null, 2)}
\`\`\`

### Response Body
\`\`\`json
${options.rawResponse.body || 'Not captured'}
\`\`\`
` : '\`\`\`\nRaw HTTP response data not captured\n\`\`\`'}

## Processed Response
\`\`\`
${options.response || 'No response captured yet'}
\`\`\`

## Performance & Timing
${options.timing ? `
- **Request Start**: ${options.timing.requestStart || 'Not captured'}
- **Response Start**: ${options.timing.responseStart || 'Not captured'}
- **Response End**: ${options.timing.responseEnd || 'Not captured'}
- **Total Duration**: ${options.timing.duration || 'Not calculated'} ms
` : '- Timing data not captured'}

## Token Usage
- **Input**: ${options.tokenUsage?.input || 'unknown'} tokens
- **Output**: ${options.tokenUsage?.output || 'unknown'} tokens

---
*Generated by OpenAnalyst Debug Capture*
`

		fs.writeFileSync(filePath, content, 'utf-8')
		console.log(`[DEBUG] API call captured: ${filename}`)
	} catch (error) {
		console.error('[DEBUG] Failed to capture API call:', error)
	}
}

/**
 * Updates an existing API call capture with raw HTTP data from provider
 * Only works when __DEV__ is true
 */
export function updateApiCallCaptureWithRawData(filename: string, rawRequest?: any, rawResponse?: any): void {
	// Only capture in development mode
	if (!__DEV__) {
		return
	}

	try {
		const debugDir = ensureDebugDirectory()
		const filePath = path.join(debugDir, "api_calls", filename)

		if (!fs.existsSync(filePath)) {
			console.warn(`[DEBUG] API call capture file not found: ${filename}`)
			return
		}

		let content = fs.readFileSync(filePath, 'utf-8')

		// Update raw HTTP request section
		if (rawRequest) {
			const rawRequestSection = `
### URL & Method
- **URL**: ${rawRequest.url || 'Not captured'}
- **Method**: ${rawRequest.method || 'Not captured'}

### Request Headers
\`\`\`json
${JSON.stringify(rawRequest.headers || {}, null, 2)}
\`\`\`

### Request Body
\`\`\`json
${rawRequest.body || 'Not captured'}
\`\`\`
`
			content = content.replace(
				/## Raw HTTP Request\n```\nRaw HTTP request data not captured\n```/,
				`## Raw HTTP Request${rawRequestSection}`
			)
		}

		// Update raw HTTP response section
		if (rawResponse) {
			const rawResponseSection = `
### Response Status
- **Status**: ${rawResponse.status || 'Not captured'}
- **Status Text**: ${rawResponse.statusText || 'Not captured'}

### Response Headers
\`\`\`json
${JSON.stringify(rawResponse.headers || {}, null, 2)}
\`\`\`

### Response Body
\`\`\`json
${rawResponse.body || 'Not captured'}
\`\`\`
`
			content = content.replace(
				/## Raw HTTP Response\n```\nRaw HTTP response data not captured\n```/,
				`## Raw HTTP Response${rawResponseSection}`
			)
		}

		fs.writeFileSync(filePath, content, 'utf-8')
		console.log(`[DEBUG] API call capture updated with raw data: ${filename}`)
	} catch (error) {
		console.error('[DEBUG] Failed to update API call capture with raw data:', error)
	}
}

/**
 * Updates an existing API call capture with response data
 * Only works when __DEV__ is true
 */
export function updateApiCallCapture(filename: string, response: string, tokenUsage?: { input?: number; output?: number }): void {
	// Only capture in development mode
	if (!__DEV__) {
		return
	}

	try {
		const debugDir = ensureDebugDirectory()
		const filePath = path.join(debugDir, "api_calls", filename)

		if (!fs.existsSync(filePath)) {
			console.warn(`[DEBUG] API call capture file not found: ${filename}`)
			return
		}

		let content = fs.readFileSync(filePath, 'utf-8')

		// Update response section
		content = content.replace(
			/## Response\n```\nNo response captured yet\n```/,
			`## Response\n\`\`\`\n${response}\n\`\`\``
		)

		// Update token usage if provided
		if (tokenUsage) {
			content = content.replace(
				/## Token Usage\n- \*\*Input\*\*: unknown tokens\n- \*\*Output\*\*: unknown tokens/,
				`## Token Usage\n- **Input**: ${tokenUsage.input || 'unknown'} tokens\n- **Output**: ${tokenUsage.output || 'unknown'} tokens`
			)
		}

		fs.writeFileSync(filePath, content, 'utf-8')
		console.log(`[DEBUG] API call capture updated: ${filename}`)
	} catch (error) {
		console.error('[DEBUG] Failed to update API call capture:', error)
	}
}